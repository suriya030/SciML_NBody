# scripts/04_train_ude.jl
# This script implements a Universal Differential Equation (UDE) for the N-body problem.
# It addresses Action Item 4 from the project roadmap: "Implement UDEs by replacing 
# the gravitational interaction term with a neural network and train using simulated data."

using ComponentArrays, Lux, DiffEqFlux, OrdinaryDiffEq, Optimization,
      OptimizationOptimisers, Random, JLD2, Plots

println("Starting UDE training script for the N-body problem...")

# --- 1. Load Training Data ---
# We use the dataset generated by `02_generate_data.jl`.
# This data contains trajectories of a 3-body system with added noise.
println("Loading training data...")
try
    global dataset = load(joinpath(@__DIR__, "..", "data", "nbody_dataset.jld2"), "dataset")
catch e
    println("Error: Could not load the dataset.")
    println("Please ensure you have run '02_generate_data.jl' successfully.")
    rethrow(e)
end

# We'll train on the first trajectory in the dataset.
t_train, data_train, u0_train = dataset[1]

# Convert data to Float32 for consistency with the neural network.
data_train = Float32.(data_train)
u0_train = Float32.(u0_train)
t_train = Float32.(t_train)
tspan = (t_train[1], t_train[end])

println("Data loaded successfully. Training on a trajectory with $(length(t_train)) time steps.")

# --- 2. Define the Neural Network ---
# This neural network will learn the missing physics, which in our case is the
# entire acceleration term (the gravitational force law).
# Input: The full state vector u (18 dimensions: 3 bodies * 3 coords + 3 bodies * 3 vels).
# Output: The accelerations dv/dt (9 dimensions: 3 bodies * 3 accels).
rng = Random.default_rng()
dudt_nn = Lux.Chain(Lux.Dense(length(u0_train), 64, tanh),
                      Lux.Dense(64, 64, tanh),
                      Lux.Dense(64, 9)) # Output is 9 for accelerations of 3 bodies

# Initialize the parameters (ps) and state (st) for the Lux model.
p, st = Lux.setup(rng, dudt_nn)
ps = ComponentArray(p) # Use ComponentArray for compatibility with Optimization.jl

# --- 3. Define the Universal Differential Equation (UDE) ---
# The UDE combines known physics with a neural network.
# Here, the "known" part is that the time derivative of position is velocity.
# The "unknown" part, the time derivative of velocity (acceleration), is replaced by our NN.
function ude_n_body_system!(du, u, p, t)
    # Known physics: dr/dt = v
    # Positions are u[1:9], Velocities are u[10:18]
    # The derivative of the first 9 components (positions) are the last 9 (velocities).
    dr = @view du[1:9]
    v = @view u[10:18]
    dr .= v

    # Unknown physics (learned by NN): dv/dt = NN(u, p)
    # The derivative of the last 9 components (velocities) is the acceleration.
    # We predict this using our neural network.
    dv = @view du[10:18]
    nn_output, _ = dudt_nn(u, p, st) # The NN takes the full state u as input
    dv .= nn_output
end

# --- 4. Define the ODE Problem and Prediction Function ---
# The ODE problem uses our UDE function. The parameters `p` of the problem
# are the neural network weights.
prob_ude = ODEProblem(ude_n_body_system!, u0_train, tspan, ps)

# The predict function solves the UDE with a given set of NN parameters `p`.
function predict_ude(p)
    # We remake the problem with the new parameters `p` and solve it.
    _prob = remake(prob_ude, p=p)
    sol = solve(_prob, Tsit5(), saveat=t_train, sensealg=QuadratureAdjoint(autojacvec=ReverseDiffVJP(true)))
    
    # Check if the solution was successful
    if sol.retcode != :Success
        # Return a large penalty if the solver fails, to guide the optimizer away
        return fill(Inf32, size(data_train))
    end
    
    return Array(sol)
end

# --- 5. Define the Loss Function ---
# The loss function calculates the difference between the UDE's prediction
# and the actual training data. The optimizer's goal is to minimize this value.
function loss_ude(p)
    pred = predict_ude(p)
    
    # If prediction failed, loss is infinite
    if any(isinf, pred)
        return Inf32
    end

    # Mean squared error loss
    loss = sum(abs2, data_train .- pred)
    return loss
end

# --- 6. Set up the Callback and Training ---
# The callback function allows us to monitor the training progress.
losses = Float32[]
callback = function (p, l)
    push!(losses, l)
    num_losses = length(losses)
    if num_losses % 10 == 0
        println("Iteration: $(num_losses) | Loss: $(l)")
    end
    # Return false to continue training
    return false
end

println("Setting up optimization problem...")
# Use Zygote for automatic differentiation
adtype = Optimization.AutoZygote()
optf = Optimization.OptimizationFunction((x, p) -> loss_ude(x), adtype)
optprob = Optimization.OptimizationProblem(optf, ps)

println("Starting UDE training...")
# We train using the Adam optimizer.
# A learning rate of 0.01 is a good starting point.
# maxiters is set to 100, but can be increased for better accuracy.
result_ude = Optimization.solve(optprob,
                                  OptimizationOptimisers.Adam(0.01);
                                  callback=callback,
                                  maxiters=500)

println("Training complete.")
ps_trained = result_ude.u

# --- 7. Save the Trained Model ---
println("Saving trained UDE parameters...")
jldsave(joinpath(@__DIR__, "..", "data", "trained_ude.jld2"); 
        ps_trained, st, dudt_nn)
println("Saved trained UDE parameters to data/trained_ude.jld2")


# --- 8. Visualize the Results ---
println("Generating final plot...")
# Get the final prediction from the trained model
pred_final = predict_ude(ps_trained)

# Create a plot comparing the true and predicted trajectories for the first body
p1 = plot(t_train, data_train[1, :], label="True - Body 1 (x)", linewidth=2,
          title="UDE Training Results vs. True Data",
          xlabel="Time", ylabel="Position")
plot!(p1, t_train, pred_final[1, :], label="Predicted - Body 1 (x)", linestyle=:dash, linewidth=2)

plot!(p1, t_train, data_train[2, :], label="True - Body 1 (y)", linewidth=2)
plot!(p1, t_train, pred_final[2, :], label="Predicted - Body 1 (y)", linestyle=:dash, linewidth=2)

# Save the plot
savefig(p1, joinpath(@__DIR__, "..", "plots", "ude_training_results.png"))
display(p1)

println("Script finished successfully.")

